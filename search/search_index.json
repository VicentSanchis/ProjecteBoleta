{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PROJECTE BOLETA","text":"<p>En aquesta avaluaci\u00f3 farem un xicotet projecte en el que una boleta caura seguint les lleis de la f\u00edsica i despr\u00e9s tamb\u00e9 podrem menejar-la i anirem augmentant la complexitat del joc conforme anem assolint els coneixements necessaris per poder fer-ho.</p> <p>??? question \"Activitat 1.  Apartat 3. En aquest tema anem a fer un joc d'una boleta amb Processing IDE. En aquest joc anem a necessitar variables on emmagatzemarem informaci\u00f3 sobre:</p> <pre><code>1. Posici\u00f3 de la boleta (coordenada X):\n2. Posici\u00f3 de la boleta (coordenada Y):\n3. Velocitat de la boleta:\n4. Direcci\u00f3 de la boleta (coordenada X):\n5. Direcci\u00f3 de la boleta (coordenada Y):\n6. Color RGB de la boleta:\n</code></pre> Activitat 303. Declaraci\u00f3 de variables <p>Seguint amb l'activitat de la boleta, llig el que hages respost a l'apartat 3 de l'activitat 301 i declara com consideres dins del bloc de \"Variables Globals\" els identificadors que hages triat com a variables amb el tipus base que trobes que es necessite.</p> <pre><code>// Variables Globals\n// Declara les variables a continuaci\u00f3 de l'exemple de velocitat\nint velocitat;  // Exemple de declaraci\u00f3 d'una variable 'velocitat'\n\nvoid setup () {\nsize(640,480);\n}\nvoid draw () {\nclear();\nbackground(255);\n}\n</code></pre> <p>Recorda que aqueta activitat l'has de fer amb Processing IDE. Guarda el fitxer resultant amb el nom seg\u00fcent: CognomNomAct303.pde que haur\u00e0s de lliurar per @ules.</p> Activitat 307. Inicialitzaci\u00f3 de variables <p>Seguint amb la boleta anem a assignar-li valors a les variables de l'activitat 303. Recorda que a aquesta activitat hem declarat totes les variables a la secci\u00f3 de 'Variables Globals' per tal que se li puga assignar valor des de qualsevol lloc. Ara haur\u00e0s de assignar-li un valor literal a cada identificador declarat com hem vist. Fixa't en l'exemple de posX.</p> <pre><code>// Variables Globals\nfloat posX, posY;\n\nvoid setup () {\nsize(640,480);\nposX = 320;\n}\nvoid draw () {\nclear();\nbackground(255);\n}\n</code></pre> <p>Guarda aquesta activitat amb el nom de: CognomNomAct307.pde per poder lliurar-lo a aules.</p> Activitat 308. Utilitza les constants al joc de la boleta <p>La finalitat del joc de la boleta, a banda de aprendre java, \u00e9s simular les lleis de la gravetat amb una boleta. Dins de les lleis de la gravetat existeix una constant que \u00e9s la for\u00e7a de la gravetat (9,8m/s\u00b2).</p> <p>Declara una constant amb nom 'GRV', o algun altre identificador significatiu i assigna-li el valor de la gravetat. Prova diversos valors de la gravetat fins que trobes aquell que siga m\u00e9s adequat.</p> <pre><code>// Declara la constant a continuaci\u00f3\n\n// Variables globals    \nfloat posX, posY;\n\nvoid setup () {\nsize(640,480);\nposX = 320;\n}\nvoid draw () {\nclear();\nbackground(255);\n}\n</code></pre> <p>Qu\u00e8 passa si al m\u00e8tode draw intentes canviar-li el valor a alguna constant? Prova-ho.</p> <p>Has de desar aquesta activitat com a CognomNomAct308.pde abans d'entregar-la.</p> <p>Abans de continuar amb l'exemple de la boleta anem a refrescar un poc la mem\u00f2ria sobre les fases de desenvolupament de programari que varem veure al primer tema i la t\u00e8cnica de disseny de diagrames de flux i la aplicarem al nostre projecte.</p> <p>1. Fase d'analisi o qu\u00e8 volem fer: Es pret\u00e8n fer una aplicaci\u00f3 amb una pantalla de temany 320 p\u00edxels d'ample  i 240 p\u00edxels d'alt amb fons blanc i una boleta de 20 p\u00edxels de diametre al mig de la pantalla en la seua posici\u00f3 inicial. Una vegada arranque l'aplicaci\u00f3 la boleta anir\u00e0 caiguent aplicant la llei de la gravetat tenint en compte que la seua velocitat incial \u00e9s zero. Quan arribe al terra, la bola desapareixer\u00e0 i s'acabar\u00e0 el programa.</p> <pre><code>- Requeriment 1: La pantalla de l'aplicaci\u00f3 \u00e9s de 320 p\u00edxels d'ample per 240 p\u00edxels d'alt.\n- Requeriment 2: La posici\u00f3 inicial de la boleta \u00e9s al mig de la pantalla (160,120)\n- Requeriment 3: La velocitat inicial de la boleta \u00e9s zero.\n- Requeriment 4: L'acceleraci\u00f3 de la boleta \u00e9s de 9,8 m/s\u00b2.\n- Requeriment 5: Quan la boleta toque terra anir\u00e0 desapareixent i acabar\u00e0 l'execuci\u00f3 del programa.\n</code></pre> <p>2. Fase de disseny: Basant-nos en l'especificaci\u00f3 de la fase d'analisi anterior i els requeriments que hem aonseguit treure, dissenyem el nostre algorisme utilitzant, per exemple, la t\u00e8cnica dels diagrames de flux. Un possible resultat podria ser el seg\u00fcent:</p> graph LR         Ini((Inici))--&gt;A[Establir Dimensions\\nAmple=320\\nAlt=240];         style Ini fill:#0F0;         A--&gt;B[Establir Posici\u00f3 Inicial\\nposX=160\\nposY=120];         B--&gt;C[GRV=0.098];         C--&gt;D[Dibuixar Bola];         D--&gt;E[Actualitzar Posici\u00f3 Bola];         E--draw: Bucle Joc--&gt;D;  <p>3. Fase d'implementaci\u00f3: Ara hem de passar el disseny a codi en Java. Coses a tenir en compte: </p> <ol> <li>Les dimensions de la boleta seran constants o variables?</li> <li>Els identificadors de la posici\u00f3 de la boleta s\u00f3n variables o constants?.</li> <li>La acceleraci\u00f3 \u00e9s una variable o una constant?</li> <li>Com puc dibuixar una boleta amb Processing IDE?</li> <li>Com s'actualitza la posici\u00f3 de la boleta?</li> <li>L'unitat de temps no \u00e9s el segon si no el frame. Com s\u00e9 en quin frame estic a l'actualitat?</li> <li>L'unitat de mesura no s\u00f3n els metres si no el p\u00edxel.</li> </ol> <p>En realitat, l'\u00fanica q\u00fcesti\u00f3 per a la que no tingau resposta \u00e9s la cinquena i \u00e9s en aquesta part on realment aplicarem operacions aritm\u00e8tiques per tal d'actualitzar la posici\u00f3 de la boleta. Per saber la posici\u00f3 de la boleta a cada frame utilitzarem les formules del MRUA per calcular la velocitat en tot moment i aix\u00ed poder actualitzar la posici\u00f3. </p> <p>Una \u00faltima consideraci\u00f3 \u00e9s que com que estem fent un simulador simple, no cal ser precisos amb les unitats de mesura i els seus valors, per exemple: la gravetat \u00e9s 9,88 metres per segon cada segon per\u00f2 per al nostre simulador anem a establir que la gravetat \u00e9s de 1 pixel per frame cada frame.</p> <p>Moviment Rectilini Uniformement Accelerat</p> <p>Amb les formules del MRUA podem saber en tot moment on es troba la boleta. Si a l'inici la boleta es troba en la posici\u00f3 y=120 i la velocitat inicial Vo=0, passat una unitat de temps (1 frame) la dist\u00e0ncia recorreguda per part de la boleta seria:</p> <pre><code>Frame 0\nVf = V0 + a*t\nVf = 0 + 1*t\nVf = 0\nPosY = PosY + Vf = 0\n</code></pre> <p>\u00c9s a dir, a l'instant zero la boleta es troba en la seua posici\u00f3 inicial i t\u00e9 una velocitat de 0 (pixels/frame). L\u00f2gic no?</p> <pre><code>Frame 1\nVf = V0 + a*t\nVf = 0 + 1*1\nVf = 1\nPosY = PosY + Vf = 1\n</code></pre> <pre><code>Frame 2\nVf = V0 + a*t\nVf = 1 + 1*1\nVf = 3\nPosY = PosY + Vf = 4\n</code></pre> <p>\u00c9s a dir, passada una unitat de temps (1 frame) la boleta haur\u00e0 recorregut 1 pixels. Continuem:</p> <pre><code>Frame 3\nVf = V0 + a*t\nVf = 3 + 1*2\nVf = 5\nPosY = Posy + Vf = 9\n</code></pre> <p>I ax\u00ed successivament fins que la boleta acabaria desapareguent per la part de baix de la nostra apliaci\u00f3.</p> Activitat 309. Fer caure la boleta <p>Escriu un programa en Java amb Processing IDE en base a les especificacions anteriors i que resolga el problema de la boleta. \u00c9s a dir, que a l'inici el programa dibuixe una boleta a la posici\u00f3 x=160 i y=120 i que com a conseq\u00fc\u00e8ncia de la for\u00e7a de la gravetat vaja caiguen fins desapareixer de lap pantalla.</p> <p>Les variables que determinen la posici\u00f3 x i y de la boleta han de tenir precisi\u00f3 flotant (float) ja que com has pogut observar a l'apartat del moviment rectilini uniformement accelerat, les distintes operacions que s'han de fer utilitzen decimals.</p> <p> </p> <p>Entrega un fitxer amb nom CognomNomAct310.pde per aules. </p> Activitat 308. Augmentem la precissi\u00f3 de la boleta <p>En aquesta activitat anem a fer que la boleta no aparega sempre a la posici\u00f3 x=160, y=120 si no que cada vegada que arranquem l'aplicaci\u00f3, aparega en un lloc diferent. </p> <p>Per tal d'aconseguir aquesta aleatorietat, utilitzarem la funci\u00f3 de Processing IDE random. </p> <p>A l'API de Processing, Processing Reference, entre altres tenim una funci\u00f3 random(low, high) que genera nombres aleatoris dintre del rang low-hight que se li passa per par\u00e0metre, \u00e9s a dir, si volem que aquesta funci\u00f3 ens torne un valor aleatori entre 0 i 100, haur\u00edem de cridar-la de la seg\u00fcent forma:</p> <pre><code>float f = random(100);   // Genera un nombre aleatori entre 0 i 100 i l'emmagatzema a f\nfloat m = random(50,90); // Genera un nombre aleatori entre 50 i 90 i l'emmagatzema a m\n</code></pre> <p>Primer fes que tant les variables que determinen la posici\u00f3 x i y de la boleta les genere la funci\u00f3 random i no siguen fixes.</p> <pre><code>// Per exmple\nposX = random(320);\n</code></pre> <p>Finalment fes que la gravetat tamb\u00e9 tinga major precissi\u00f3 i assigna-li un valor de 0.0098.</p> <p>Continuem amb la boleta i ampliem funcionalitats i millorem el diagrama de flux de la fase de disseny</p> graph LR         Ini((Inici))--&gt;A[Establir Dimensions\\nAmple=320\\nAlt=240];         style Ini fill:#0F0;         A--&gt;B[Establir Posici\u00f3 Inicial\\nposX=160\\nposY=120];         B--&gt;C[Acceleraci\u00f3=1];         C--&gt;D[Dibuixar Bola];         D--&gt;E[Actualitzar Posici\u00f3 Bola];         E--&gt;F{Ha tocat terra?};         F--&gt;|SI|G[posX=0];         G--&gt;H[velocitat = 0];         H--&gt;D;         F--&gt;|NO|D;          Activitat 315. Que no desaparega la boleta <p>Hem d'aconseguir que la boleta no desaparega quan arribe a la part de baix de l'aplicaci\u00f3 sino torne a apareixer per dalt. Qu\u00e8 singfica que la boleta ha arribat al terra? o dit d'una altra manera, com sabem que la boleta ha arribat baix del tot? Per qu\u00e8 la el valor de la variable que indica la posici\u00f3 a l'eix Y de la boleta \u00e9s major que l'alt de la nostra aplicaci\u00f3, \u00e9s a dir: 240. Per tant podem deduir que: \"Si la posici\u00f3 Y de la boleta \u00e9s major que 240 aleshores la fem apareixer per dalt...\"</p> <p>Com podeu observar, l'afirmaci\u00f3 anterior \u00e9s un if, si posY \u00e9s major (&gt;) altura aleshores fes apareixer per dalt de nou la boleta. Per\u00f2 quines s\u00f3n les accions a realitzar per tal que la boleta aparega per dalt? tornar a posar la posici\u00f3 Y de la boleta a 0.</p> <p>Un problema que ens trobarem ac\u00ed \u00e9s que no podem ja utilitzar la variable de sistema frameCount ja que quan la boleta torne a apareixer per dalt el n\u00famero de frames (el que utilitzem com a unitat de temps) ha de comen\u00e7ar de zero una altra vegada. La soluci\u00f3 \u00e9s crear una variable numFrames com a global que s'inicialitze a zero al setup i cada vegada que haja d'apareixer per dalt, es torna a assignar un zero a aquesta variable.</p> <p>Tamb\u00e9 s'ha de reiniciar la velocitat a zero sino no parar\u00e0 d'accelerar.</p> <p><pre><code>    // Constants\nfinal static float GRV = 1;   // For\u00e7a de la gravetat\nfinal static int   TAM = 20;  // Tamany de la boleta\n\n// Variables Globals\nint   numFrames;\nfloat velocitat;              // Velocitat inicial de l'objecte quan arranquem el programa.\nfloat posX, posY;             // Variables que determinen la posici\u00f3 de la boleta en un escenari de dues dimensions\n\n// M\u00e8tode setup: inicialitza la nostra aplicaci\u00f3, dona valors inicials.\nvoid setup () {\nsize(320,240);               // Establir dimensions\nposX      = random(20,300);  // Establim posici\u00f3 X inicial\nposY      = random(20,220);  // Establim posici\u00f3 Y inicial\nvelocitat = 0;               // Establim la velocitat inicial\nnumFrames = 0;               // Variable necess\u00e0ria per controlar l'acceleraci\u00f3.\n}\n\n// Metode draw: bucle del joc, aquest m\u00e8tode s'executa de forma continua\nvoid draw () {\nclear();\nbackground(255);\nfill(0);\nellipse(posX,posY,TAM,TAM);\n\n// Actualitzem la posici\u00f3 utilitzant la velocitat\nposY = posY + velocitat;\nvelocitat = velocitat + G*numFrames;  // Vf = Vo + acc*temps;\nnumFrames ++;\n\n// Codi if que controle si ha arribat al terra o no.\n// if...\n}\n</code></pre> </p> Activitat 316. Correcci\u00f3 d'errades amb el depurador <p>Com haur\u00e0s vist quan has executat el codi, el comportament del que fa el nostre codi amb la boleta no \u00e9s el que esperavem, o almenys jo ho imaginava d'una altra manera. Revisa-ho i canvia alguns detalls. Fes una depuraci\u00f3 l\u00ednia a l\u00ednia del codi amb el Debugger de Processing IDE i deixa l'apliaci\u00f3 com a tu t'agradaria.</p> <p>Pista: igual quan torna a apareixer per dalt la velocitat no deuria ser zero...</p> <p>Continuem amb el Projecte Boleta. Per tal de treballar l'estructura condicional doble que acabem de veure ampliarem les funcionalitat de la nostra aplicaci\u00f3. Ara volem que quan la boleta toque terra siga de color roig i quan no estiga tocant, continue siguent negra.  </p> <p>El diagrama de flux amb els nous requeriments quedaria aix\u00ed:</p> graph LR         Ini((Inici))--&gt;A[Establir Dimensions\\nAmple=320\\nAlt=240];         style Ini fill:#0F0;         A--&gt;B[Establir Posici\u00f3 Inicial\\nposX=160\\nposY=120];         B--&gt;C[Acceleraci\u00f3=1];         C--&gt;D[Dibuixar Bola];         D--&gt;E[Actualitzar Posici\u00f3 Bola];         E--&gt;F{Ha tocat terra?};         F--&gt;|SI|G[posX=0\\nPintaRoig];         G--&gt;H[velocitat = 0];         H--&gt;D;         F--&gt;|NO|I[PintaNegre];         I--&gt;D;          Activitat 319. Boleta de dos colors <p>observa el diagrama de flux anterior i modifica el codi de l'activitat 319 per tal d'afegir-li les noves funcionalitats. Finalment l'aplicaci\u00f3 quearia de la seg\u00fcent forma:</p> <p> </p> <p>Ampliaci\u00f3: Fes que la boleta quan comence a apareixer per dalt siga totalment negra i poc a poc conforme va baixant vaja anant cap al color roig gradualment. Nom\u00e9s pots utilitzar les estructures que hem vist fins ara: seq\u00fcencial, if simple i if - else.</p> <p> </p> Activitat 321. Canvi de color de la boleta segons l'altura en la que es troba <p>Anem a fer que en el nostre projecte de la boleta que cau, aquesta canvie de color segons l'altura de la pantalla a la qual es troba. </p> <p>Tenint en compte que la nostra pantalla t\u00e9 una altura de 240 p\u00edxels, dividirem la nostra pantalla en 6 franges de 40 p\u00edxels d'altura cadascuna (6*40=240). Mentre la bola estiga passant per la primera franja (0-40) aquesta ser\u00e0 de color roig, a la segona franja (40-80) la pintarem de color taronja. A la tercera (80-120) groga, (120-160) verda, (160-200) blava i finalment a l'\u00faltima franja (200-240) ser\u00e0 de color morat.</p> <p>Traduit al llenguatge natural podria ser: si la posici\u00f3 (posY) de la boleta esta entre 0 i 40 pinta-la de roig, sino si la boleta esta entre 40 i 40 pinta-la de taronja sino si ....</p> <p>Al final el resultat de l'aplicaci\u00f3 podria ser el seg\u00fcent:</p> <p> </p> <p>Ampliaci\u00f3: Observa els codis rgb dels colors i intenta que el canvi de color de la boleta siga gradual i no de cop.</p> Activitat 332. Boleta amb cursors <p>Seguint amb l'exemple de la boleta en Processing IDE, completa el seg\u00fcent codi per tal que quan premem un cursor del nostre teclat, la boleta comence a menejar-se en eixa direcci\u00f3. A l'inici de l'aplicaci\u00f3, la boleta estar\u00e0 parada.</p> <pre><code>// Variables globals\nint posX, posY, vel;\n\n// Configuraci\u00f3 de l'aplicaci\u00f3 (nom\u00e9s s'executa una vegada al principi)\nvoid setup () {\nsize(640,480);  // Tamany de monitor est\u00e0ndard VGA\nposX = 320;\nposY = 240;\nvel  = 0;\n}\n\nvoid draw () {\nclear();\nbacground(255);\nellipse(posX, posY, 30, 30);\n\nif (posX &gt;= 640 )\nposX = 0;\n}\n\nvoid keyPressed() {\nswitch (keyCode) {\ncase UP:\n// Ac\u00ed anir\u00e0 el codi per que la boleta es meneje cap amunt\nbreak;\n\ncase DOWN:\n// Ac\u00ed anir\u00e0 el codi per que la boleta vaja cap avall.\nbreak;\n\ncase LEFT:\n// Codi per moure la boleta cap a l'esquerra.\nbreak;\n\ncase RIGHT:\n// Codi per moure la boleta cap a la dreta.\nbreak;\n}\n}\n</code></pre>"}]}