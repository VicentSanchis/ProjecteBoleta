{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Projecte Bola de Drac El projecte de la bola de drac \u00e9s un xicotet joc que desenvoluparem a classe amb Java i Processing IDE . En aquest projecte comen\u00e7arem simulant un sistema de f\u00edsiques molt simple en el que una bola caur\u00e0 poc a poc gr\u00e0cies a la for\u00e7a de la gravetat. Poc a poc i al mateix temps que anem assolint els coneixements necessaris ampliarem les funcionalitats de la bola, per exemple que puga rebotar quan toque les vores de l'aplicaci\u00f3, que puguem utilitzar els cursors al joc per impulsar o moure la bola. Finalment podriem afegir tamb\u00e9 obstacles, enemics i animacions... El llenguatge Java En aquest tema 3 hem vist b\u00e0sicament la sintaxi de Java. \u00c9s per tant el tema m\u00e9s dens que hem vist de moment i amb molts conceptes que assolir. A continuaci\u00f3 i basant-nos en aquest xicotet projecte, revisarem un a un aquests conceptes construint pas a pas el projecte. Si no recordes algun concepte vist a classe, et recomane que revises els apartats mentre anem mirant-los. Comencem per les dades, variables i identificadors. Dades Variables identificadors El primer que has de fer \u00e9s molt senzill, obre l'entorn de desenvolupament integrat de Processing IDE , copia el codi que tens a continuaci\u00f3 i apega'l a l'editor. Aquest codi ser\u00e0 la base per al projecte de la boleta que desenvoluparem pas a pas. Finalment guarda'l amb el nom ProjecteBola.pde per exemple. Codi base sobre el que construirem el projecte 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Projecte Bola de Drac * ------------------------------------------------------------------------------------------------------ * Xicotet projecte de simulaci\u00f3 d'un sistema de f\u00edsiques que finalment acabar\u00e0 convertint-se en un joc * simple amb enemics, obstacles i puntuaci\u00f3 * @author Vicent Sanchis * @since 10/10/2023 * @version 1.0 */ // ------------------------------------------------------------------------------------------------------ // Constants // ------------------------------------------------------------------------------------------------------ // Variables Globals // ------------------------------------------------------------------------------------------------------ /** * M\u00e8tode setup * M\u00e8tode de configuraci\u00f3 de l'aplicaci\u00f3, nom\u00e9s s'executa una volta * Ac\u00ed solen anar les inicialitzacions i setup inicial * @return void */ void setup ( ) { size ( 640 , 480 ); // Defineix la grand\u00e0ria de la pantalla de la nostra aplicaci\u00f3 } /** * M\u00e8tode draw * M\u00e8tode que s'executa tantes vegades per segon com fps estiga configurat * Tamb\u00e9 conegut com el bucle de joc. Ac\u00ed va el principal del programa * @return void */ void draw () { } Si executes el codi que has copiat amb el Processing IDE veuras que nom\u00e9s ix una pantalla de 640 pixels per 480 pixels i res m\u00e9s. No et preocupes, \u00e9s normal. Ara anirem poc a poc afegint el codi necessari per anar construint el nostre joc. Activitat 1. Identificadors del nostre projecte Problema Soluci\u00f3 En aquest joc anem a necessitar una s\u00e8rie de variables on emmagatzemarem informaci\u00f3 sobre: 1. Posici\u00f3 de la boleta (coordenada X): 2. Posici\u00f3 de la boleta (coordenada Y): 3. Velocitat de la boleta (coordenada X): 4. Velocitat de la boleta (coordenada Y): 5. Color RGB de la boleta: Per a cadascuna de futures variables anteriors tria un identificador seguint les normes de creaci\u00f3 d'identificadors vistes a classe i que siga significatiu. 1. Posici\u00f3 de la boleta (coordenada X): posX 2. Posici\u00f3 de la boleta (coordenada Y): posY 3. Velocitat de la boleta (coordenada X): velX 4. Velocitat de la boleta (coordenada Y): velY 5. Color RGB de la boleta: colorRGB (utilitzarem un tipus especial que es diu **color**) Una vegada ja tenim els identificadors escollits ens quedaria posar-los al nostre projecte. \u00c9s a dir, has de declarar les variables associades als identificadors de l'activitat anterior al nostre projecte. Recorda que declarar una variable b\u00e0sicament consisteix en associar-li a l'identificador el tipus de dades adequat. Activitat 2. Declaraci\u00f3 de variables al projecte Problema Soluci\u00f3 Llig el que hages respost a l'activitat anterior i declara com consideres dins del bloc de \"Variables Globals\" els identificadors que hages triat com a variables amb el tipus base que trobes que es necessite. Mira l'exemple de la variable velocitat si no saps per on comen\u00e7ar. 1 2 3 4 5 6 7 8 9 10 // Declara les variables globals a la seua secci\u00f3. int velX ; // Exemple de declaraci\u00f3 d'una variable 'velocitat' void setup () { size ( 640 , 480 ); } void draw () { clear (); background ( 255 ); // Pinta el fons de blanc } Recorda que aquesta activitat l'has de fer amb Processing IDE . Guarda el fitxer resultant amb el nom seg\u00fcent: ProjecteBola.pde Descarrega la soluci\u00f3 de l'activitat 2 Operadors i expressions Ja tens les variables necess\u00e0ries per poder comen\u00e7ar amb el projecte declarades al teu fitxer ProjecteBola.pde ara per poder seguir amb el joc, has de donar-los algun valor inicial a les variables declarades a l'activitat anterior. Recorda que per donar valor a una variable s'han d'utilitzar dues coses que has vist al tema 3: l'operador assignaci\u00f3 = i un literal del mateix tipus que siga la variable a la qual vols donar valor. Les assignacions de valors inicials a les variables del nostre projecte es faran dins del setup . Teniu en compte que \u00e9s en aquest m\u00e8tode en el que es solen configurar les aplicacions, per tant, \u00e9s un bon lloc per poder donar-los a les variables el seu valor inicial amb el que comen\u00e7aran quan s'execute l'app. Activitat 3. Inicialitzaci\u00f3 de variables del projecte Problema Soluci\u00f3 Com que hem declarat totes les variables a la secci\u00f3 de 'Variables Globals' per tal que se li puga assignar valor des de qualsevol lloc. Ara haur\u00e0s de assignar-li un valor literal a cada identificador declarat com hem vist. Fixa't en l'exemple de posX. 1 2 3 4 5 6 7 8 9 10 11 // Variables Globals int posX , posY ; void setup () { size ( 640 , 480 ); posX = 320 ; } void draw () { clear (); background ( 255 ); } Guarda aquesta activitat amb el nom de: ProjecteBola.pde Descarrega la soluci\u00f3 de l'activitat 3 Constants Com has vist al Tema 3 les constants s\u00f3n identificadors que representen valors immutables durant l'execuci\u00f3 del programa. Trobes que podriem usar alguna constant al nostre projecte?. Mira l'activitat seg\u00fcent: Activitat 4. \u00das de constants al nostre projecte Problema Soluci\u00f3 La finalitat del joc de la boleta, a banda de aprendre java, \u00e9s simular les lleis de la gravetat amb una boleta. Dins de les lleis de la gravetat existeix una constant que \u00e9s la for\u00e7a de la gravetat (9,8m/s\u00b2). Declara una constant amb nom 'GRV', o algun altre identificador significatiu i assigna-li el valor de la gravetat. Prova diversos valors de la gravetat fins que trobes aquell que siga m\u00e9s adequat. 1 2 3 4 5 6 7 8 9 10 11 12 13 // Declara la constant a la secci\u00f3 de constants // Variables globals int posX , posY ; void setup () { size ( 640 , 480 ); posX = 320 ; } void draw () { clear (); background ( 255 ); } Qu\u00e8 passa si al m\u00e8tode draw intentes canviar-li el valor a alguna constant en temps d'execuci\u00f3? Prova-ho. Descarrega la soluci\u00f3 de l'activitat 4 Estructures Abans de continuar amb l'exemple de la boleta anem a refrescar un poc la mem\u00f2ria sobre les fases de desenvolupament de programari que varem veure al primer tema i la t\u00e8cnica de disseny de diagrames de flux i la aplicarem al nostre projecte. 1. Fase d'analisi o qu\u00e8 volem fer Es pret\u00e9n fer una aplicaci\u00f3 amb una pantalla de grand\u00e0ria 640 p\u00edxels d'ample i 480 p\u00edxels d'alt amb fons blanc i una boleta de 20 p\u00edxels de diametre al mig de la pantalla en la seua posici\u00f3 inicial. Una vegada arranque l'aplicaci\u00f3 la boleta anir\u00e0 caent aplicant la llei de la gravetat tenint en compte que la seua velocitat inicial \u00e9s zero. Quan arribe al terra, la bola desapareixer\u00e0 i s'acabar\u00e0 el programa. - Requeriment 1: La pantalla de l'aplicaci\u00f3 \u00e9s de 640 p\u00edxels d'ample per 480 p\u00edxels d'alt. - Requeriment 2: La posici\u00f3 inicial de la boleta \u00e9s al mig de la pantalla dalt (320,50) - Requeriment 3: La velocitat inicial de la boleta \u00e9s zero. - Requeriment 4: L'acceleraci\u00f3 de la boleta \u00e9s de 9,8 m/s\u00b2. - Requeriment 5: Quan la boleta toque terra anir\u00e0 desapareixent i acabar\u00e0 l'execuci\u00f3 del programa. 2. Fase de disseny Basant-nos en l'especificaci\u00f3 de la fase d'analisi anterior i els requeriments que hem aconseguit treure, dissenyem el nostre algorisme utilitzant, per exemple, la t\u00e8cnica dels diagrames de flux . Un possible resultat podria ser el seg\u00fcent: graph LR Ini((Inici))-->A[GRV=0.098]; A-->B[Establir Dimensions Ample=640 Alt=480]; style Ini fill:#0F0; B-->C[Establir Posici\u00f3 Inicial posX=320 posY=50]; C-->D[Actualitzar Posici\u00f3 Bola]; D-->E[Dibuixar Bola]; E--draw: Bucle Joc-->D; 3. Fase d'implementaci\u00f3 Ara hem de passar el disseny a codi en Java. Coses a tenir en compte: - Les dimensions de la boleta seran constants o variables? - Els identificadors de la posici\u00f3 de la boleta s\u00f3n variables o constants?. - La acceleraci\u00f3 \u00e9s una variable o una constant? - Com puc dibuixar una boleta amb Processing IDE? - Com s'actualitza la posici\u00f3 de la boleta? - L'unitat de temps no \u00e9s el segon si no el frame. Com s\u00e9 en quin frame estic a l'actualitat? - L'unitat de mesura no s\u00f3n els metres si no el p\u00edxel. En realitat, l'\u00fanica q\u00fcesti\u00f3 per a la que possiblement no tingues resposta \u00e9s la cinquena i \u00e9s en aquesta part on realment aplicarem operacions aritm\u00e8tiques per tal d'actualitzar la posici\u00f3 de la boleta. Per saber la posici\u00f3 de la boleta a cada frame utilitzarem les formules del MRUA per calcular la velocitat en tot moment i aix\u00ed poder actualitzar la posici\u00f3. Una \u00faltima consideraci\u00f3 \u00e9s que com que estem fent un simulador simple, no cal ser precisos amb les unitats de mesura i els seus valors, per exemple: la gravetat \u00e9s 9,88 metres per segon cada segon per\u00f2 per al nostre simulador anem a establir que la gravetat (acceleraci\u00f3) \u00e9s de 1 pixel per frame cada frame. Moviment Rectilini Uniformement Accelerat Per tal de fer els c\u00e0lculs m\u00e9s simple i comprensibles, considerem que GRV val 1. Amb les formules del MRUA podem saber en tot moment on es troba la boleta. Si a l'inici la boleta es troba en la posici\u00f3 y=120 i la velocitat inicial a l'eix Y velY=0, passat una unitat de temps (1 frame) la dist\u00e0ncia recorreguda per part de la boleta seria: // Frame 0 velY = velY + a * t velY = velY + GRV * ( frameCount / frameRate ); velY = 0 + 1 * 0 ; velY = 0 ; posY = posY + velY = 0 ; \u00c9s a dir, a l'instant zero la boleta es troba en la seua posici\u00f3 inicial i t\u00e9 una velocitat de 0 (pixels/frame). L\u00f2gic no? // Frame 1 velY = velY + GRV * ( frameCount / frameRate ); velY = 0 + 1 * ( 1 / 60 ) velY = 1 / 60 ; posY = posY + velY = 1 / 60 ; // Frame 2 velY = velY + GRV * ( frameCount / frameRate ); velY = 1 / 60 + 1 * ( 2 / 60 ); velY = 1 / 60 + 2 / 60 ; posY = posY + velY = 1 / 60 + 2 / 60 ; posY = 3 / 60 ; \u00c9s a dir, passada una unitat de temps (1 frame) la boleta haur\u00e0 recorregut 3/60 pixels. Continuem: // Frame 3 velY = velY + GRV * ( frameCount / frameRate ); velY = 3 / 60 + 1 * ( 3 / 60 ); velY = 3 / 60 + 3 / 60 ; posY = posY + velY = 3 / 60 + 3 / 60 ; posY = 6 / 60 I ax\u00ed successivament fins que la boleta acabaria desapareixent per la part de baix de la nostra aplicaci\u00f3. En conclusi\u00f3, eixa instrucci\u00f3 del diagrama de flux anterior que hi posa Actualitzar Posici\u00f3 Bola en realitat seria: velY=velY+GRV*(frameCount/frameRate) i posY = posY + velY. Si has llegit i ent\u00e8s l'explicaci\u00f3 anterior sobre el Moviment rectilini uniformement accelerat , fes l'activitat 5 on per primera vegada es veur\u00e0 la boleta en moviment. Activitat 5. Fer caure la boleta Problema Soluci\u00f3 Escriu un programa en Java amb Processing IDE en base a les especificacions anteriors i que resolga el problema de la boleta. \u00c9s a dir, que a l'inici el programa dibuixe una boleta a la posici\u00f3 x=320 i y=50 i que com a conseq\u00fc\u00e8ncia de la for\u00e7a de la gravetat vaja caent fins desapareixer de la pantalla de la nostra aplicaci\u00f3. Les variables que determinen la posici\u00f3 i la velocitat de la boleta han de tenir precisi\u00f3 flotant (float) ja que com has pogut observar a l'apartat del moviment rectilini uniformement accelerat, les distintes operacions que s'han de fer utilitzen decimals. CONSIDERACI\u00d3: Penses que la grand\u00e0ria de la boleta podria ser una constant? Descarrega la soluci\u00f3 de l'activitat 5 Abans de passar a la seg\u00fcent secci\u00f3, millorem el que ja tenim fet. El que es preten amb aquesta activitat \u00e9s que el punt d'inici de la boleta no siga sempre el mateix i varie cada vegada que s'arranque el joc. Llig i fes la seg\u00fcent activitat: Activitat 6. Que la boleta no aparega sempre al mateix lloc Problema Soluci\u00f3 En aquesta activitat anem a fer que la boleta no aparega sempre a la posici\u00f3 x=320, y=50 si no que cada vegada que arranquem l'aplicaci\u00f3, aparega en un lloc diferent. Per tal d'aconseguir aquesta aleatorietat, utilitzarem la funci\u00f3 de Processing IDE random . A l'API de Processing, Processing Reference , entre altres tenim una funci\u00f3 random(low, high) que genera nombres aleatoris dintre del rang low-hight que se li passa per par\u00e0metre, \u00e9s a dir, si volem que aquesta funci\u00f3 ens torne un valor aleatori entre 0 i 100, haur\u00edem de cridar-la de la seg\u00fcent forma: 1 2 float f = random ( 100 ); // Genera un nombre aleatori entre 0 i 100 i l'emmagatzema a f float m = random ( 50 , 90 ); // Genera un nombre aleatori entre 50 i 90 i l'emmagatzema a m Primer fes que tant les variables que determinen la posici\u00f3 x i y de la boleta les genere la funci\u00f3 random i no siguen fixes. 1 2 // Per exemple posX = random ( 640 ); Tamb\u00e9 fes que la gravetat tamb\u00e9 tinga major precisi\u00f3 i assigna-li un valor de 0.0098. Si executes prou vegades l'activitat 6 t'adonar\u00e0s que de vegades la boleta apareix en els extrems de la pantalla i de vegades tant baixeta que no s'arriba a apreciar el seu comportament. Investiga la funci\u00f3 random de Processing API i fes que la boleta aparega sempre entre els seg\u00fcents rangs: posX entre 100 i 540 posY entre 50 i 150 Descarrega la soluci\u00f3 de l'activitat 6 Estructura de selecci\u00f3 simple Fent \u00fas de les estructures de selecci\u00f3 vistes al tema 3, farem que el nostre joc siga m\u00e9s eficient i prec\u00eds. Si has fet les activitats anteriors haur\u00e0s pogut observar que la boleta desapareix per la part de baix de la nostra aplicaci\u00f3 i no la tornem a veure. Anem a corregir este comportament utilitzant una estructura de selecci\u00f3 if Continuem amb la boleta i ampliem funcionalitats i millorem el diagrama de flux de la fase de disseny graph LR Ini((Inici))-->A[GRV=0.098f]; A-->B[Establir Dimensions Ample=640 Alt=480]; style Ini fill:#0F0; B-->C[Establir Posici\u00f3 Inicial posX=random xMin-xMax posY=random yMin-yMax]; C-->E[Actualitzar Posici\u00f3 Bola velY=velY+GRV*frameCount/frameRate posY=posY+velY]; E-->F{Ha desaparegut?}; F-->|SI|G[posX=0]; G-->H[velY = 0]; H-->D; F-->|NO|D; D[Dibuixar Bola]; D--Draw: Bucle Joc-->E; El primer que farem en aquesta secci\u00f3 \u00e9s que la boleta no desaparega. Fins ara la nostra boleta apareix en un lloc random de la finestra de l'aplicaci\u00f3 i comen\u00e7a a caure fins que desapareix. Hem d'evitar aix\u00f2 com mostra el diagrama de flux. Activitat 7. Que no desaparega la boleta Problema Soluci\u00f3 Hem d'aconseguir que la boleta torne a apareixer per dalt quan arribe desaparega per la part de baix de l'aplicaci\u00f3. Qu\u00e8 significa que la boleta ha desaparegut per baix? o dit d'una altra manera, com sabem que la boleta ha desaparegut per complet? Per qu\u00e8 la el valor de la variable que indica la posici\u00f3 a l'eix Y posY de la boleta \u00e9s major que l'alt de la nostra aplicaci\u00f3 m\u00e9s la meitat de la grand\u00e0ria de la boleta, \u00e9s a dir: 495. Per tant podem deduir que: \"Si la posici\u00f3 Y de la boleta \u00e9s major que 495 aleshores la fem apareixer per dalt...\" Com podeu observar, l'afirmaci\u00f3 anterior \u00e9s un if , si posY \u00e9s major (>) altura aleshores fes apareixer per dalt de nou la boleta. Per\u00f2 quines s\u00f3n les accions a realitzar per tal que la boleta aparega per dalt? tornar a posar la posici\u00f3 Y de la boleta a 0 menys la meitat de la seua grand\u00e0ria (TAM). Tamb\u00e9 s'ha de reiniciar la velocitat a zero sino no parar\u00e0 d'accelerar. Comprovaci\u00f3: Qu\u00e8 passa si canvies el valor de TAM a 50? Funciona com hauria de funcionar? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // Constants final static float GRV = 0.098f ; // For\u00e7a de la gravetat final static int TAM = 30 ; // Grand\u00e0ria de la boleta // Variables Globals float velX , velY ; // Velocitat inicial de l'objecte quan arranquem el programa. float posX , posY ; // Variables que determinen la posici\u00f3 de la boleta en un escenari de dues dimensions // M\u00e8tode setup: inicialitza la nostra aplicaci\u00f3, dona valors inicials. void setup () { size ( 640 , 480 ); // Establir dimensions posX = random ( 40 , 600 ); // Establim posici\u00f3 X inicial posY = random ( 40 , 440 ); // Establim posici\u00f3 Y inicial velX = 0 ; // Establim la velocitat X inicial velY = 0 ; // Establim la velocitat Y inicial } // Metode draw: bucle del joc, aquest m\u00e8tode s'executa de forma continua void draw () { clear (); background ( 255 ); // Actualitzem la posici\u00f3 utilitzant la velocitat velY = velY + GRV * ( frameCount / frameRate ); // Vf = Vo + acc*temps; posY = posY + velY ; // Codi if que controle si ha arribat al terra o no. // if... // Dibuixem la boleta fill ( 0 ); circle ( posX , posY , TAM ); } Descarrega la soluci\u00f3 de l'activitat 7 El depurador de Processing IDE Ha arribat el moment que aprengues com funciona el depurador que \u00e9s una eina molt important per a desenvolupar codi. El depurador o debugger \u00e9s una eina molt important i necess\u00e0ria que porten tots els entorns de desenvolupament integrat com Processing. Aquesta eina ens permet executar el codi pas a pas al mateix temps que podem monitoritzar el valor de les variables, l'estat dels diferent objectes que formen part de la nostra aplicaci\u00f3. Per poder activar el depurador hem de fer clic al bot\u00f3 red\u00f3 que es troba dalt a la dreta de l'editor com es mostra a la imatge anterior. Una vegada tenim el depurador activat, se'ns obre el monitor de variables que ens permetr\u00e0 controlar com canvien les variables de valor. A la part esquerra ens apareixeran els controls que ens habilitaran per poder navegar pas a pas o entrar en funcions i m\u00e8todes del codi. Finalment \u00e9s molt important tamb\u00e9 per a la depuraci\u00f3 de codi el terme breakpoint per fer que el depurador pare en un lloc espec\u00edfic del nostre codi, li ho hem d'indicar amb punts de ruptura o breakpoints. Per poder posar un breakpoint nom\u00e9s hem de fer clic sobre el n\u00famero de la l\u00ednia sobre la que volem que s'apare l'execuci\u00f3 del programa. Per tal de llevar-lo tornem a punxar sobre la mateixa l\u00ednia. Una vegada hages provat el depurador de Processing IDE i tingues m\u00e9s o menys clar com funciona, fes l'activitat seg\u00fcent. Activitat 8. Correcci\u00f3 d'errades amb el depurador Problema Soluci\u00f3 Com haur\u00e0s vist quan has executat el codi, el comportament del que fa el nostre codi amb la boleta no \u00e9s el que esperavem, o almenys jo ho imaginava d'una altra manera. Dona la sensaci\u00f3 que cada vegada que la boleta apareix a la part de dalt de la pantalla de l'aplicaci\u00f3, va cada vegada m\u00e9s de pressa. Per qu\u00e8? Revisa el codi, troba on est\u00e0 el problema i fes els canvis necessaris. Per facilitar la tasca, fes una depuraci\u00f3 l\u00ednia a l\u00ednia del codi amb el Debugger de Processing IDE i deixa l'aplicaci\u00f3 com a tu t'agradaria. Pista: igual quan torna a apareixer per dalt el temps es deuria resetejar a 0 i comen\u00e7ar de zero. Ho est\u00e0 fent aix\u00ed? Com ho podries canviar? Descarrega la soluci\u00f3 de l'activitat 8 Estructura de selecci\u00f3 doble Per tal de treballar l'estructura condicional doble que acabem de veure ampliarem les funcionalitats de la nostra aplicaci\u00f3. Ara volem que quan la boleta comence de tocar terra es pinte de color roig i redueixca la seua velocitat en l'eix y en un 50%. Quan no estiga tocant terra, que siga de color negre. Has de tindre en compte que la boleta es dibuixa a partir del seu center (posX, posY) i que per tant la boleta comen\u00e7ar\u00e0 a tocar terra quan la dist\u00e0ncia que hi ha entre el centre de la boleta i terra siga menor o igual que l'altura de la nostra aplicaci\u00f3 m\u00e9s la meitat de la seua grand\u00e0ria. El diagrama de flux amb els nous requeriments quedaria aix\u00ed: graph LR Ini((Inici))-->A[GRV=0.98f]; style Ini fill:#0F0; A-->B[Establir Dimensions Ample=640 Alt=480]; B-->C[Establir Posici\u00f3 Inicial posX=random xMin, xMax posY=random yMin, yMax]; C-->D[Actualitzar Posici\u00f3 Bola vevY=velY + GRV*frameCount/frameRate posY=posY+velY]; D-->F{Ha tocat terra?}; F-->|SI|G[PintaRoig Frena Boleta]; F-->|NO|H[PintaNegre]; G-->P1(fa:fa-spinner); H-->P1; P1-->I{Ha desaparegut?}; I-->|SI|J[velY=0 posY=-TAM/2 frameCount=0]; J-->K[Dibuixar Bola]; K--Draw: bucle joc-->D; Estudia amb detall el diagrama de flux anterior i fes la seg\u00fcent activitat. Activitat 9. Boleta de dos colors Problema Soluci\u00f3 Observa el diagrama de flux anterior i modifica el codi de que ja tens per tal d'afegir-li les noves funcionalitats. La dist\u00e0ncia a partir de la qual la boleta es faria roja \u00e9s quan comen\u00e7a a tocar terra i per una altra banda has de comprovar tamb\u00e9 quan ha desaparegut completament. Concretament en el teu codi deuries tindre: una estructura de selecci\u00f3 simple (la de l'activitat anterior) i una altra doble, la nova funcionalitat. Finalment l'aplicaci\u00f3 quedaria de la seg\u00fcent forma: Algunes consideracions: has de canviar el tipus de posX i posY a float per augmentar la precisi\u00f3. Descarrega la soluci\u00f3 de l'activitat 9 Estructura de selecci\u00f3 niada Com recordar\u00e0s el que hem donat al tema 3, l'estructura de selecci\u00f3 niada \u00e9s una estructura de programaci\u00f3 en la que poden haver m\u00e9s d'una condici\u00f3. A l'activitat anterior teniem dues condicions: desapareixer i tocar terr\u00e0, en canvi no hem utilitzat l'estructura de selecci\u00f3 niada. Modifica el codi anterior i converteix una estructura simple i una doble en una estructura \u00fanica estructura de selecci\u00f3 niada com mostra el seg\u00fcent diagrama de flux. graph LR Ini((Inici))-->A[GRV=0.98f]; style Ini fill:#0F0; A-->B[Establir Dimensions Ample=640 Alt=480]; B-->C[Establir Posici\u00f3 Inicial posX=random Xmin, Xmax posY=random Ymin, Ymax]; C-->D[Actualitzar Posici\u00f3 Bola vevY=velY+GRV*frameCount/frameRate posY=posY+velY]; D-->F{Ha tocat terra i NO ha desaparegut?}; F-->|SI|G[PintaRoig Frena Boleta]; G-->K; F-->|NO|H{Ha desaparegut?}; H-->|SI|I[velY=0 posY=-TAM/2 frameCount=0]; I-->K; H-->|NO|J[PintaNegre]; J-->K[Dibuixar Bola]; K--Draw: bucle joc-->D; Activitat 10. Modifica el codi anterior Problema Soluci\u00f3 Observa el diagrama de flux anterior i modifica el codi de l'activitat 9 per tal que en lloc de tindre dues estructures condicionals en tinga una niada. Ampliaci\u00f3: Fes que la boleta canvie de color segons l'altura en la que es trobe, per exemple: els primers 50 pixels que siga negra, els seg\u00fcents siga taronja, a partir del pixel 100 i fins el 150 groga, i aix\u00ed successivament sempre sense modificar el comportament anterior. Has d'entregar dos fitxers en aquesta activitat: Activitat10.pde i Activitat10Ampliada.pde Descarrega la soluci\u00f3 de l'activitat 10 Estructura de selecci\u00f3 m\u00faltiple Treballem a continuaci\u00f3 l'estructura de selecci\u00f3 m\u00faltiple: switch case . Per poder treballar amb el switch li afegirem alguna funcionalitat nova al nostre joc. Es tracta de poder interaccionar amb la boleta, \u00e9s a dir, es pret\u00e9n que quan premem al teclat algun cursor (dalt, baix, esquerra, dreta) la boleta es menege en eixa direcci\u00f3 o se li done alguna classe d'impuls cap a eixa direcci\u00f3 concreta. Per poder aconseguir aix\u00f2 hem d'usar un esdeveniment que ens ofereix la llibreria de Processing IDE . Aquest esdeveniment es diu keyPressed i ve en forma de funci\u00f3 en la que podem escriure tot el codi que necessite. Abans de passar a fer l'activitat 11, entra al Reference de Processing IDE , investiga b\u00e9 qu\u00e8 \u00e9s aix\u00f2 del keyPressed , com funciona i quines coses es podrien fer. Algunes consideracions Abans de programar el codi necessari per controlar el moviment de la boleta a la seg\u00fcent activitat, has de fer-te lse seg\u00fcents q\u00fcestions: Qu\u00e8 pense que passar\u00e0 si prem un cursor qualsevol (amunt, avall, dreta o esquerra)? Si vull que la boleta no pare de moure's, he de deixar el bot\u00f3 pres? Si prem el bot\u00f3 dret nom\u00e9s una vegada, es mour\u00e0 nom\u00e9s durant un frame o continuar\u00e0 movent-se mentre no li indique el contrari? Puc parar la boleta? Com ho faria? Per continuar amb el projecte de la boleta, canviarem un poc el diagrama de flux. Com pots observar a continuaci\u00f3, la gravetat ja no existeix, ara la boleta apareixer\u00e0 al mig de la pantalla de la nostra aplicaci\u00f3 i no comen\u00e7ar\u00e0 a moure's fins que premem algun cursor del teclat seguint la l\u00f2gica del joc de la serp. Per tal de poder implementar aquest tipus de moviment, necessitem de dues variables m\u00e9s que ens indiquen en quina direcci\u00f3 est\u00e0 anant la nostra boleta. Mira la taula seg\u00fcent. dirX dirY On Va 0 0 Parat 0 -1 Avall 0 1 Amunt 1 0 Dreta -1 0 Esquerra D'altra banda el que abans era la velocitat, un vector de dues coordenades, passa a ser una magnitud entera, \u00e9s a dir, nom\u00e9s un sol valor. graph LR Ini((Inici))-->A[Establir Dimensions Ample=640 Alt=480 Establir Posici\u00f3 posX=320 posY=240 Establir Direcci\u00f3 dirX=0 dirY=0 Establir velocitat vel=3]; style Ini fill:#0F0; A-->B[Actualitzar Posici\u00f3\\nposX+=dirX*vel\\nposY+=dirY*vel]; B-->C[Dibuixar Bola]; C-->D{Tecla premuda?}; D-->|NO|C; D-->|SI|E{Esdeveniment keyPressed}; E-->|UP|F[Amunt dirX=0\\ndirY=-1]; E-->|DOWN|G[Avall dirX=0 dirY=1]; E-->|LEFT|H[Esquerra dirX=-1 dirY=0]; E-->|RIGHT|I[Dreta dirX=1 dirY=0]; F-->J(fa:fa-spinner); G-->J; H-->J; I-->J; J--Draw: bucle joc-->C; Activitat 11. Boleta amb cursors Problema Soluci\u00f3 A partir de l'activitat 9 li donarem interactivitat amb l'usuari a la nostra boleta. Per fer la base del nostre joc, seguirem la l\u00f2gica del joc de la serp com ja he comentat abans. Aquell joc en que una serp persegueix boletes que apareixen aleat\u00f2riament a la pantalla i conforme \"se les menja\" va creixent augmentant la dificultat (ja veurem com). Completa el seg\u00fcent codi per tal que quan premem un cursor del nostre teclat, la boleta comence a menejar-se en eixa direcci\u00f3. A l'inici de l'aplicaci\u00f3, la boleta estar\u00e0 parada. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // Variables globals float posX , posY , vel ; int dirX , dirY ; // Compte que ac\u00ed hem afegit les variables dirX i dirY // necess\u00e0ries per indicar en quina direcci\u00f3 va la boleta // Configuraci\u00f3 de l'aplicaci\u00f3 (nom\u00e9s s'executa una vegada al principi) void setup () { size ( 640 , 480 ); // Grand\u00e0ria de monitor est\u00e0ndard VGA posX = 320 ; posY = 50 ; dirX = 0 ; dirY = 0 ; vel = 3 ; } void draw () { clear (); background ( 255 ); ellipse ( posX , posY , 30 , 30 ); } void keyPressed () { switch ( keyCode ) { case UP : // Ac\u00ed anir\u00e0 el codi per que la boleta es menege cap amunt break ; case DOWN : // Ac\u00ed anir\u00e0 el codi per que la boleta vaja cap avall. break ; case LEFT : // Codi per moure la boleta cap a l'esquerra. break ; case RIGHT : // Codi per moure la boleta cap a la dreta. break ; } } Descarrega la soluci\u00f3 de l'activitat 11 Programaci\u00f3 Modular Com has pogut observar en els diagrames de flux que hem anat fent al nostre projecte, va augmentant en complexitat i cada vegada s\u00f3n m\u00e9s dif\u00edcils de interpretar. Ha arribat l'hora de modularitzar el nostre joc. Basant-nos en el diagrama de flux anterior observa el seg\u00fcent diagrama simplificat. graph LR Ini((Inici))-->A[Inicialitzar App]; style Ini fill:#0F0; A-->B[Actualitzar Boleta]; B-->C[Dibuixar Bola]; C-->D[Comprovar Pulsacions keyPressed]; D--Draw: bucle joc-->C; Com pots observar, hem simplificat molt el diagrama anterior per\u00f2 hauria de continuar funcionant igualment. El que hem fet ha sigut substituir els conjunts d'instruccions del diagrama anterior per funcionalitats m\u00e9s gen\u00e8riques. Aix\u00ed: 1. Inicialitzar App: s'encarregar\u00e0 de establir dimensions, establir la posici\u00f3 i la direcci\u00f3 inicial de la boleta. 2. Actualitzar Boleta: s'encarregar\u00e0 de en base als valors que tinguen dirX, dirY i velocitat de modificar els valors de posX i posY com hem vist en activitats anteriors. 3. Dibuixar boleta: s'encarregar\u00e0 de dibuixar la boleta al lloc de l'aplicaci\u00f3 que li corresponga. 4. Comprovar pulsacions: s'encarregar\u00e0 de gestionar els esdeveniments de teclats. B\u00e0sicament seria * keyPressed. Activitat 12. Modularitza el codi del projecte Problema Soluci\u00f3 Seguint a partir del codi que hem desenvolupat a l'activitat 11, has de modularitzar el codi creant les seg\u00fcents funcions: inicialitzarJoc, actualitzarPosicio, dibuixar. De moment la funcionalitat de comprovar pulsacions s'encarregar\u00e0 el m\u00e8tode de l'API de Processing keyPressed . Descarrega la soluci\u00f3 de l'activitat 11 Par\u00e0metres Com hem vist al tema 4, les funcions en programaci\u00f3 permeten la seua parametritzaci\u00f3, \u00e9s a dir, poder condicionar el funcionament dels m\u00e8todes mitjan\u00e7ant l'\u00fas de par\u00e0metres i arguments. La q\u00fcesti\u00f3 \u00e9s si podem o no utilitzar aquesta caracter\u00edstica de la programaci\u00f3 modular a la nostra aplicaci\u00f3. Normalment la parametritzaci\u00f3 de m\u00e8todes serveix entre altres coses per evitar l'\u00fas de les variables globals que a la llarga solen portar problemes. En el nostre cas de moment algunes variables com les de posici\u00f3 i direcci\u00f3 de la boleta no podem evitar que siguen globals, per\u00f2 hi ha altres que igual seria convenient que no ho foren. Llig i fes l'activitat 13. Activitat 13. Parametritzaci\u00f3 de funcions Problema Soluci\u00f3 Revisa el codi que has escrit a l'activitat 12 de modularitzaci\u00f3 i raona el seg\u00fcent. Hi ha algun m\u00e8tode dels que he has escrit que siga susceptible de ser parametritzat? Reescriu el codi parametritzant les funcions que consideres necess\u00e0ries i raona el motiu en els comentaris de documentaci\u00f3 al codi. Descarrega la soluci\u00f3 de l'activitat 13 Pas d'objectes a funcions Un dels apartats que hem vist al tema de programaci\u00f3 modular \u00e9s l'\u00fas d'objectes i funcions. Com que nosaltres encara no hem entrat en Programaci\u00f3 Orientada a Objectes no entrarem massa en detall del que \u00e9s una classe, un objecte i/o una inst\u00e0ncia per\u00f2 s\u00ed que ens introduirem un poc en el m\u00f3n dels objectes. Anem a utilitzar l'objecte PVector que ens proporciona l'API de Processing per treballar amb vectors de coordenades. Llig l'article PVector de la guia de Processing IDE i despr\u00e9s fes la seg\u00fcent activitat. Has de tenir en compte que encara que els vectors de posici\u00f3 i direcci\u00f3 siguen variables globals, s'haurien de passar per par\u00e0metre a aquells m\u00e8todes que ho necessiten. Activitat 14. \u00das d'objectes i funcions Problema Soluci\u00f3 Com haur\u00e0s llegit a l'article PVector \u00e9s una classe que s'utilitza per representar vectors de dos o tres dimensions. En el nostre cas necessitariem fer \u00fas del vector de dues dimensions per raons obvies. Hauries de declarar dos PVectors, un per la posici\u00f3 de la boleta i un altre per a la direcci\u00f3 de la boleta. 1 2 3 4 5 6 7 8 9 10 11 // Exemple de com es declara un objecte de la classe PVector PVector nomVector ; // Exemple de com s'inicia un objecte de la classe PVector nomVector = new PVector ( a , b ); // On 'a' i 'b' s\u00f3n els valors que s'assignaran a la coordenada x i y respectivament. // Tamb\u00e9 es podria declarar un vector buit i assignar-li les coordenades a posteriori nomVector = new PVector (); nomVector . x = a ; nomVector . y = b ; Descarrega la soluci\u00f3 de l'activitat 14 Sobre el return Si has arribat a aquest punt, segurament t'haur\u00e0s donat compte que la boleta quan arriba a algun dels extrems de la pantalla: dalt, baix, esquerra o dreta; la boleta desapareix i no torna a apareixer a no ser que li canviem la direcci\u00f3 i posem la contraria que tenia quan ha desaparegut. Per tal de solucionar aquest problema crearem un m\u00e8tode superaLimits que s'encarregar\u00e0 per a cada frame de comprovar si la boleta ha superat algun dels l\u00edmits del nostre joc. Aquest m\u00e8tode b\u00e0sicament far\u00e0 el seg\u00fcent: graph LR Ini((Inici))-->A{Supera l\u00edmit superior?}; style Ini fill:#0F0; A-->|SI|B[return true]; A-->|NO|C{Supera l\u00edmit inferior?}; C-->|SI|B; C-->|NO|D{Supera l\u00edmit esquerre?}; D-->|SI|B; D-->|NO|E{Supera l\u00edmit dret?}; E-->|SI|B; E-->|NO|F[return false]; F-->Fin((Fi)); style Fin fill:#F00; B-->Fin; Finalment nom\u00e9s ens quedaria saber que fer quan la boleta a arribat algun dels l\u00edmits de la pantalla. S'hauria de parar? Hauria de rebotar? En cas de rebotar, en quina direcci\u00f3 ho faria? Des del meu punt de vista i amb la idea de joc que es preten fer, si la boleta toca un l\u00edmit, haur\u00e0 de rebotar en direcci\u00f3 contraria. Per exemple, si la boleta va en direcci\u00f3 dreta (dirX=1, dirY=0) hauria de rebotar cap a l'esquerra (dirX=-1, dirY=0). Si pel contrari, la boleta va cap avall (dirX=0, dirY=1) passar\u00e0 a anar cap amunt (dirX=0, dirY=-1). Com pots observar, rebotar significa multiplicar per menys \u00fa la direcci\u00f3 actual de la boleta, per tant podem concloure que el diagrama de flux final d'aquesta activitat quedaria de la seg\u00fcent forma. graph LR Ini((Inici))-->A[Inicialitzar App]; style Ini fill:#0F0; A-->B[Actualitzar Boleta]; B-->C[Dibuixar Bola]; C-->D[Comprovar Pulsacions keyPressed]; D-->E{SuperaLimit?} E-->|Si|F[Rebota]; E-->|No|B; F-->B; El que s\u00ed est\u00e0 clar \u00e9s que la funci\u00f3 ha de tornar un valor boole\u00e0 que ens indique si la boleta ha superat algun marge (true) o no (false) Activitat 15. Detecci\u00f3 de vores Problema Soluci\u00f3 Seguint el exemple que hem posat al diagrama de flux anterior, dissenya una funci\u00f3 que es podria dir superaLimits que ens retorne un valor true en cas que la boleta desaparega per algun l\u00edmit i false en cas contrari. En el bucle de joc haur\u00e0s de cridar a dita funci\u00f3 per comprovar a cada frame si la boleta toca o no algun l\u00edmit de l'aplicaci\u00f3. Al mateix temps segons la resposta (true o false) que ens done la crida al m\u00e8tode superaLimits haurem de prendre la decisi\u00f3 de qu\u00e8 fem amb ella: parar, rebotar.. Segueix el diagrama de flux anterior i implementa l'activitat. Descarrega la soluci\u00f3 de l'activitat 15 Tipus Compostos de Dades Aprofitant que al tema de tipus compostos de dades hem vist algunes col\u00b7leccions o conjunts (arrays i matrius), veiem com podem afegir-li m\u00e9s funcionalitats al nostre projecte de la boleta. Com que ja podem moure la boleta per la pantalla de la nostra aplicaci\u00f3 amb els cursors, donem-li un objectiu al nostre personatge. Farem que la finalitat del joc siga que la nostra boleta persegueixi i es \"menge\" enemics . Suposem que aquests enemics s\u00f3n cercles d'un color diferent al de la boleta que apareixen de forma aleat\u00f2ria per la pantalla i es mantenen en la mateixa posici\u00f3 durant tot el joc, a m\u00e9s a m\u00e9s, en el moment que apareixen la boleta els ha de tocar per poder eliminar-los. Podriem fer, per exemple, que els enemics comencen a apareixer passat un temps i que vagen apareixent fins arribar a un m\u00e0xim de 10 enemics en total. El joc acaba quan la boleta s'haja \"menjat\" a tots els enemics. Analitzem amb m\u00e9s profunditat el plantejament anterior i vegem quins podrien ser els seus requeriments. Requeriments Hem de guardar informaci\u00f3 sobre la posici\u00f3 dels enemics igual que feiem anb la boleta. Els enemics apareixen de forma aleat\u00f2ria (posici\u00f3) a la pantalla cada cert temps (interval) constant. Els enemics s\u00f3n est\u00e0tics. No es poden moure i mantenen sempre la mateixa posici\u00f3. Simple de moment. Hi haur\u00e0 un m\u00e0xim de 10 enemics de forma simult\u00e0nia al nostre joc. Per \"menjar-se\" un enemic, la boleta haur\u00e0 de col\u00b7lisionar amb l'enemic, \u00e9s a dir, tocar-lo. El joc finalitza quan la boleta s'ha menjat a tots els enemics. D'alguna manera hem de poder guardar la informaci\u00f3 necess\u00e0ria d'un conjunt d'enemics al nostre programa. Sembla l\u00f2gic que usarem un array d'una dimensi\u00f3 per aquesta tasca, per\u00f2 quin tipus de dades ha de guardar aquest array. Si ho penses b\u00e9 dels enemics nom\u00e9s necessitem saber-ne la posici\u00f3 en la que es troben, \u00e9s a dir, podriem usar un array de PVectors. Diagrama de flux Veiem a continuaci\u00f3 un possible disseny de les ampliacions de funcionalitats del nostre joc al diagrama de flux graph LR Ini((Inici))-->A[\"Inicialitzar App (setup)\"]; style Ini fill:#0F0; A-->B[\"Actualitza Boleta (draw)\"]; B-->C[\"Actualitza Enemics (draw)\"]; C-->D[\"Dibuixa Boleta (draw)\"]; D-->E[\"Dibuixa Enemics (draw)\"]; E-->F[\"Comprovar col\u00b7lisions (draw)\"]; F-->G[\"Comprovar pulsacions (keyPressed)\"]; G-->H{Queden enemics?}; H-->|Si|I{Supera Limit?}; H-->|No|J[Finalitzar Joc]; I-->|Si|K[Rebota]; I-->|No|B; J-->Fi((Fi)); style Fi fill:#F00; K-->B; Com es pot observar al diagrama de flux anterior hi han poques difer\u00e8ncies amb el que haviem fet a l'activitat 15. Apareixen les seg\u00fcents novetats: Instruccions: Actualitzar enemics, Dibuixar enemics, Comprovar col\u00b7lisions, Finalitzar Joc. Condicions: Queden enemics? En realitat, com ja haur\u00e0s imaginat, eixes noves instruccions en realitat s\u00f3n m\u00e8todes nous del nostre joc. Expliquem-los amb m\u00e9s detall: 1. Actualitzar enemics: aquest m\u00e8tode s'encarrega de gestionar la llista d'enemics assignant-los cada un cert interval de temps una posici\u00f3 a aquells que encara no hagen aparegut que no es modificar\u00e0 durant tot el joc fins que se'l mengen. En definitiva, aquest m\u00e8tode \u00e9s el que porta el control del temps per tal d'anar assignant posicions aleat\u00f2ries als enemics que van apareixent. Tamb\u00e9 ha de tindre en compte que nom\u00e9s es poden mostrar un m\u00e0xim de 10 enemics al nostre joc. graph LR Ini((Inici))-->A{Queden enemics per mostrar?}; style Ini fill:#0F0; A-->|Si|B{Han passat 'x' segons?}; A-->|No|Fi((Fi)); style Fi fill:#F00; B-->|Si|C[Genera posici\u00f3 nova Guarda posici\u00f3 Incrementa contEnemics]; C-->A; B-->|No|B; 2. Dibuixar enemics: aquest m\u00e8tode haur\u00e0 de rec\u00f3rrer l'array amb les posicions dels enemics, en cas d'haver-ne alguna (recorda que \u00e9s actualitzar enemics la que s'encarrega d'a\u00e7\u00f2) i dibuixar els cercles (enemics) corresponents. graph LR Ini((Inici))-->A[Obt\u00e9 Enemic de l'array]; style Ini fill:#0F0; A-->B[Dibuixa enemic]; B-->C{Queden enemics per mostrar?}; C-->|Si|A; C-->|No|Fi((Fi)); style Fi fill:#F00; 3. Comprovar col\u00b7lisions: aquest \u00e9s possiblement el m\u00e8tode m\u00e9s complex. A cada cicle del bucle del joc s'haur\u00e0 de comprovar si la nostra boleta, com a conseq\u00fc\u00e8ncia de la seua nova posici\u00f3 una vegada ja s'ha actualitzat, est\u00e0 col\u00b7lisionant amb algun enemic. Per saber si la boleta est\u00e0 col\u00b7lisionant amb algun enemic es pot saber de la seg\u00fcent manera: si la dist\u00e0ncia entre la posici\u00f3 de la boleta i la posici\u00f3 de l'enemic \u00e9s menor que la suma del radi de la boleta i el de l'enemic, significa que s'estan tocant i per tant s'hauria d'eliminar l'enemic. Per poder realitzar aquests c\u00e0lculs pots aprofitar les funcionalitats que ens ofereix el PVector de l'API de Processing. graph LR style Ini fill:#0F0; Ini((Inici))-->A[Obt\u00e9 Enemic de l'array]; A-->B{dist entre enemic i boleta menor que suma radis?}; B-->|Si|C[Elimina]; C-->A; B-->|No|D{Queden enemics?}; D-->|Si|A; D-->|No|Fi((Fi)); style Fi fill:#F00; 4. Queden enemics: en aquesta condici\u00f3 s'ha de comprovar si ja hem menjat a tots els enemics i en aquest cas finalitzariem el joc. Compte que fins que no apareix el primer enemic es podria pensar que ja no queden enemics i finalitzar el joc sense haver-lo comen\u00e7at. Has de dissenyar b\u00e9 aquest m\u00e8tode per tal que aix\u00f2 no passe. La millor forma es amb un comptador d'enemics morts que seria zero a l'inici de l'aplicaci\u00f3 i 10 quan ens els hajam menjat a tots. El comptador de morts s'actualitzar\u00e0 cada vegada que es detecte una col\u00b7lisi\u00f3 i es mate un enemic. En aquesta funci\u00f3 es podria aprofitar per mostrar un comptador per pantalla on s'indique el total d'enemics que s'ha menjat la boleta. 5. Finalitzar joc: \u00e9s un m\u00e8tode que s'encarregaria de fer veure a l'usuari que la partida ja ha finalitzat, \u00e9s a dir, el t\u00edpic Gave Over . B\u00e0sicament \u00e9s una condici\u00f3 en alguna part del codi on es comprove si el total de morts \u00e9s igual a 10, en cas de ser aix\u00ed, es mostrar\u00e0 un missatge de GAME OVER enmig de la pantalla. Alguns dubtes que potser t'estar\u00e0s preguntant: Com guarde informaci\u00f3 de la posici\u00f3 dels enemics? Has d'utilitzar un array de PVectors com s'ha comentat abans amb capacitat per a 10 elements. Cadascun d'aquests PVectors tindran la informaci\u00f3 de la posici\u00f3 d'un enemic. En cas que aquest siga null significaria que encara no ha aparegut. En quin moment comence a mostrar enemics? Has de portar un control del temps, una bona manera pot ser utilitzar la variable frameCount de Processing per\u00f2 tamb\u00e9 hi ha altres alternatives com les funcions de temps de l'API de Processing. Per exemple, cada 60 frames podries considerar que ha passat un segon, encara que no seria massa prec\u00eds. Mira les funcions de temps que ens permet usar Processing perqu\u00e8 es pot utilitzar tamb\u00e9 m\u00e9s endavant per fer un comptador de temps. Per exemple imagina que l'interval en el que apareixen els enemics \u00e9s de 200 frames o de 5 segons, el primer enemic apareixeria passats 200 frames o 5 segons des de l'inici de l'aplicaci\u00f3. Una vegada a aparegut el primer enemic esperaria uns altres 200 frames o 5 segons per mostrar el seg\u00fcent i aix\u00ed successivament. Com se si han aparegut o no? Com que tens un array de PVectors que t'indica la posici\u00f3 de tots els enemics, \u00e9s f\u00e0cil deduir que si el contingut en la posici\u00f3 2 de l'array \u00e9s nul\u00b7la significa que encara no ha aparegut. Com s'eliminen enemics? Posant a null el contingut de l'array de PVectors seria una opci\u00f3. Com se si ja els he eliminat a tots? Deuries portar un comptador de col\u00b7lisions. Amb una variable global es podria solucionar. Activitat 16. Gesti\u00f3 d'enemics Problema Soluci\u00f3 A partir de l'especificaci\u00f3 de requeriments anterior i el diagrama de flux de les noves funcionalitats del nostre joc. Implementa-les i afegeix-les al teu codi del projecte de la boleta. Recorda que hauran d'apareixer de forma aleat\u00f2ria i cada cert temps un m\u00e0xim de 10 enemics que la nostra boleta s'haur\u00e0 de menjar per considerar el joc acabat. Descarrega la soluci\u00f3 de l'activitat 15 Programaci\u00f3 orientada a objectes Canviem el paradigma de programaci\u00f3 del nostre joc de la boleta. Si fins ara el que hem fet ha sigut imaginar un conjunt de procediments que hem programat basant-nos en el paradigma de programaci\u00f3 estructurada, ara hem de fer el proc\u00e9s d'abstracci\u00f3 de la nostra aplicaci\u00f3 i veure-la com un conjunt d'objectes que tenen un comportament concret. Per\u00f2 comencem pel principi i seguim els passos que hem vist al Tema 6. 1. Quins elements de la nostra aplicaci\u00f3 han de ser desats o s'han de tenir en compte? La boleta, els enemics i un marcador (nou) que ens indicar\u00e0 tant el temps com les puntuacions (enemics mostrats i morts) 2. De cada element, quines dades ens interessen? Boleta: color, posici\u00f3, direcci\u00f3, velocitat, color, grand\u00e0ria. Enemic: posicio, color, grandaria. Marcador: posici\u00f3, dimensions, temps transcorregut, interval (temps entre que apareix un enemic i el seg\u00fcent), pr\u00f2xim interval (quan podr\u00e0 tornar a apareixer un enemic), marcadors (punts)... 3. A cada element, quines operacions associarem? Boleta: mostrar-se, actualitzar-se, moure's cap amunt, avall, dreta i esquerra, col\u00b7lisionar amb Enemics, rebotar, parar.. Enemic: mostrar-se, morir. Marcador: mostrar-se, actualitzar-se, controlar el temps i els marcadors dividits en dos: puntsA que ser\u00e0 el total d'enemics mostrats i puntsB que seran els que ja hem eliminat. El fet de que el marcador parle de puntsA i puntsB en lloc de enemics apareguts i morts \u00e9s perqu\u00e8 l'objecte marcador no ha de saber el significat dels valors que mostra (puntsA i puntsB) per tal de fer-lo m\u00e9s gen\u00e8ric i m\u00e9s reutilitzatble a altres aplicacions. De les respostes a les q\u00fcestions anteriors, el que hauriem de fer ara \u00e9s dissenyar un xicotet diagrama de classes que represente la realitat anterior. Per exemple: classDiagram direction LR Bola: int grandaria Bola: float velocitat Bola: color pinta Bola: PVector posicio Bola: PVector direccio Bola: Bola() Bola: Bola(Pvector pos, Pvector dir, float vel, int tam, color col) Bola: void mostra() Bola: void actualitza() Bola: void para() Bola: boolean colisionaAmb (Enemic e) Bola: boolean superaLimits (int alt, int ample) Bola: void giraDreta() Bola: void giraEsquerra() Bola: void giraDalt() Bola: void giraBaix() Enemic: PVector posicio Enemic: int grandaria Enemic: color pinta Enemic: Enemic() Enemic: void mostra() Enemic: PVector getPosicio() Enemic: int getGrandaria() Marcador: int ample Marcador: int alt Marcador: PVector posicio Marcador: int currentTime Marcador: int timeLapse Marcador: int nextLapse Marcador: int puntsA Marcador: int puntsB Marcador: String lblPuntsA Marcador: String lblPuntsB Marcador: bool passatInterval Marcador: Marcador() Marcador: Marcador(String strA, String strB, int lapse) Marcador: void mostra() Marcador: void actualitza() Marcador: void sumaPuntsA() Marcador: void sumaPuntsB() Marcador: int getPuntsA() Marcador: int getPuntsB() Marcador: String getTime() Marcador: boolean haPassatInterval() Main \"1\" --> \"1\" Bola Main \"1\" --> \"10\" Enemic Main \"1\" --> \"1\" Marcador Main: int maxEnemics=10 Main: void setup() Main: void draw() Main: inicilialitzaApp() Main: keyPressed() A partir d'aquest diagrama de classes ara ens quedaria implementar-les en Processing IDE per despr\u00e8s poder utilitzar-les des de l'aplicaci\u00f3 principal. Per tal de poder utilitzar les classes creades al pas anterior, podriem implementar una aplicaci\u00f3 main com la que mostra el seg\u00fcent diagrama de flux: graph LR subgraph \"GESTI\u00d3 MARCADOR\" style Ini fill:#0F0; Ini((Inici))-->A[Mostra Marcador]; A-->B{Queden enemics per matar?}; B-->|Si|C[Actualitza Marcador]; C-->D{Queden enemics per mostrar Y Ha passat un interval?}; D-->|Si|E[Crea Enemic Afegeix-lo Suma Apareguts]; end subgraph \"GESTI\u00d3 DE LA BOLETA\" D-->|No|F; E-->F[Mostra Bola Actualitza Bola]; F-->G{Supera Limits?}; G-->|Si|H[Rebota]; end subgraph \"GESTI\u00d3 DELS ENEMICS\" G-->|No|I; H-->I{Hi han enemics per mostrar?}; I-->|Si|J[Mostra Enemic]; I-->|No|B; J-->K{Col\u00b7lisiona amb la boleta}; K-->|Si|L[Elimina Enemic Suma Punts]; L-->I; K-->|No|I; end classDef primer fill:#EFF, clear:both, display:inline, clear: both class 1 primer class 2 primer class 3 primer class 4 primer Al final el resultat podria ser de la seg\u00fcent manera: Activitat 17. Conversi\u00f3 a POO Problema Soluci\u00f3 Converteix el joc de la boleta al paradigma de programaci\u00f3 orientada a objectes. Intenta seguir els passos que s'han explicat al tema 6 amb l'exemple del volc\u00e0 que s\u00f3n els mateixos que acabem d'explicar a l'apartat anterior. Descarrega la soluci\u00f3 de l'activitat 15 Classe Animator - Reutilitzaci\u00f3 de classes Fins ara els elements que hem usat per fer el nostre joc de la boleta s\u00f3n figures geom\u00e8triques est\u00e0tiques el que fa que en general siga un poc avorrit. En aquest seg\u00fcent apartat aprendrem com convertir els nostres objectes en figures animades. Aprofitant una de les caracter\u00edstiques principals del paradigma de Programaci\u00f3 Orientada a Objectes, la reutlitzaci\u00f3 del codi, incorporarem una nova classe al nostre joc: la classe Animation que podeu descarregar Ac\u00ed . Aquesta classe ens permet mitjan\u00e7ant l'\u00fas de sprite sheets crear animacions per al nostre personatge com la seg\u00fcent: Utlitzar aqueta classe \u00e9s relativament senzill: Incorporem la classe al nostre projecte copiant-la a la mateixa carpeta com una classe pr\u00f2pia m\u00e9s. Declarem un atribut Animation a qualsevol classe del nostre projecte que vulgam animar. Al constructor de la classe que volem animar instanciem l'objecte animation seguint les instruccions de la classe. Exemple d'\u00fas de la classe Animation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Animation trump ; void setup () { size ( 200 , 200 ); trump = new Animation ( \"Trump\" , \"./img/trump_run.png\" , 100 , 100 , 4 , 6 , 0 ); } void draw () { clear (); background ( 235 ); trump . display ( new PVector ( width / 2 , height / 2 ), 1 , 1 ); trump . update (); } Senzill no? Per\u00f2 com aconseguim que la nostra boleta es converteixca en un personatge animat com el de l'exemple anterior? Hem d'afegir un nou atribut a la nostra classe Boleta, aquest nou membre s'instanciar\u00e0 al constructor de la classe Boleta i finalment al m\u00e8tode mostrar de la boleta \u00e9s on cridarem al m\u00e8tode display de l'animaci\u00f3, finalment al m\u00e8tode actualitza de la boleta \u00e9s des d'on cridarem al m\u00e8tode update de l'animaci\u00f3. Per\u00f2 abans d'anar per feina, observem b\u00e9 l'spritesheet: Amb el constructor amb el que hem instanciat el nostre objecte trump li indiquem els seg\u00fcents arguments: - \"Trump\": etiqueta que s'utilitza per identificar els frames de l'animaci\u00f3. - \"./imt/trump_run.png\": ruta del nostre full d'sprites. - 100: ample de cada frame de l'animaci\u00f3 (cada Trumpet) - 100: alt de cada frame de l'animaci\u00f3 (cada Trumpet) - 4: files de l'sprite sheet - 6: columnes de l'sprite sheet - 0: aquest argument ens indica si nom\u00e9s volem agafar una fila (nombre de la fila que volem) per full o totes les files (zero). Al nostre cas hem posta zero el que significa que volem que l'animaci\u00f3 carregue tots els frames de l'spritesheet. 1 Animation trump = new Animation ( \"Trump\" , \"./img/trump_run.png\" , 100 , 100 , 4 , 6 , 0 ); Com he dit, el que hem fet ha sigut carregar tot l'sprite sheet en una sola animaci\u00f3 quan en realitat el que tenim \u00e9s un full d'sprites amb quatre animacions com mostra la seg\u00fcent imatge. Cada fila \u00e9s una animaci\u00f3 diferent. El que hauriem de fer per tant \u00e9s que la nostra classe Trump no tinga nom\u00e9s un atribut animation com fins ara sino que tinga quatre atributs de la classe Animation per a simular cadascun dels diferents moviments que pot fer el nostre personatge. Tamb\u00e9 necessitarem una \u00faltima animaci\u00f3 que ens servir\u00e0 per indicar quina \u00e9s l'animaci\u00f3 actual o la que s'estiga executant en un moment concret. Finalment ens quedaria implementar el codi necessari per que quan el personatge canvie de direcci\u00f3 ho faja tamb\u00e9 l'animaci\u00f3 que s'est\u00e0 executant. Aix\u00f2 ho fariem als diferents m\u00e8todes gira que hem implementat a la classe boleta. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // Teniu en compte que animAvall, animDreta, animAmunt, currentAnim s\u00f3n nous atributs de la classe Bola private void carregaAnimacions () { this . animAvall = new Animation ( \"Trump\" , \"./img/trump_run.png\" , 100 , 100 , 4 , 6 , 1 ); this . animDreta = new Animation ( \"Trump\" , \"./img/trump_run.png\" , 100 , 100 , 4 , 6 , 2 ); this . animAmunt = new Animation ( \"Trump\" , \"./img/trump_run.png\" , 100 , 100 , 4 , 6 , 3 ); this . animEsquerra = new Animation ( \"Trump\" , \"./img/trump_run.png\" , 100 , 100 , 4 , 6 , 4 ); this . currentAnim = animAvall ; } public void giraDreta () { this . direccio = new PVector ( 1 , 0 ); this . currentAnim = animDreta ; } public void giraEsquerra () { this . direccio = new PVector ( - 1 , 0 ); this . currentAnim = animEsquerra ; } public void giraDalt () { this . direccio = new PVector ( 0 , - 1 ); this . currentAnim = animAmunt ; } public void giraBaix () { this . direccio = new PVector ( 0 , 1 ); this . currentAnim = animAvall ; } public void mostra () { fill ( pinta ); strokeWeight ( 1 ); this . currentAnim . display ( posicio , 1 , 1 ); } public void actualitza () { this . posicio . add ( this . direccio . copy (). mult ( velocitat )); this . currentAnim . update (); } El resultat de les modificacions al codi anteriors seria el seg\u00fcent:","title":"Index"},{"location":"#projecte-bola-de-drac","text":"El projecte de la bola de drac \u00e9s un xicotet joc que desenvoluparem a classe amb Java i Processing IDE . En aquest projecte comen\u00e7arem simulant un sistema de f\u00edsiques molt simple en el que una bola caur\u00e0 poc a poc gr\u00e0cies a la for\u00e7a de la gravetat. Poc a poc i al mateix temps que anem assolint els coneixements necessaris ampliarem les funcionalitats de la bola, per exemple que puga rebotar quan toque les vores de l'aplicaci\u00f3, que puguem utilitzar els cursors al joc per impulsar o moure la bola. Finalment podriem afegir tamb\u00e9 obstacles, enemics i animacions...","title":"Projecte Bola de Drac"},{"location":"#el-llenguatge-java","text":"En aquest tema 3 hem vist b\u00e0sicament la sintaxi de Java. \u00c9s per tant el tema m\u00e9s dens que hem vist de moment i amb molts conceptes que assolir. A continuaci\u00f3 i basant-nos en aquest xicotet projecte, revisarem un a un aquests conceptes construint pas a pas el projecte. Si no recordes algun concepte vist a classe, et recomane que revises els apartats mentre anem mirant-los. Comencem per les dades, variables i identificadors.","title":"El llenguatge Java"},{"location":"#programacio-modular","text":"Com has pogut observar en els diagrames de flux que hem anat fent al nostre projecte, va augmentant en complexitat i cada vegada s\u00f3n m\u00e9s dif\u00edcils de interpretar. Ha arribat l'hora de modularitzar el nostre joc. Basant-nos en el diagrama de flux anterior observa el seg\u00fcent diagrama simplificat. graph LR Ini((Inici))-->A[Inicialitzar App]; style Ini fill:#0F0; A-->B[Actualitzar Boleta]; B-->C[Dibuixar Bola]; C-->D[Comprovar Pulsacions keyPressed]; D--Draw: bucle joc-->C; Com pots observar, hem simplificat molt el diagrama anterior per\u00f2 hauria de continuar funcionant igualment. El que hem fet ha sigut substituir els conjunts d'instruccions del diagrama anterior per funcionalitats m\u00e9s gen\u00e8riques. Aix\u00ed: 1. Inicialitzar App: s'encarregar\u00e0 de establir dimensions, establir la posici\u00f3 i la direcci\u00f3 inicial de la boleta. 2. Actualitzar Boleta: s'encarregar\u00e0 de en base als valors que tinguen dirX, dirY i velocitat de modificar els valors de posX i posY com hem vist en activitats anteriors. 3. Dibuixar boleta: s'encarregar\u00e0 de dibuixar la boleta al lloc de l'aplicaci\u00f3 que li corresponga. 4. Comprovar pulsacions: s'encarregar\u00e0 de gestionar els esdeveniments de teclats. B\u00e0sicament seria * keyPressed. Activitat 12. Modularitza el codi del projecte Problema Soluci\u00f3 Seguint a partir del codi que hem desenvolupat a l'activitat 11, has de modularitzar el codi creant les seg\u00fcents funcions: inicialitzarJoc, actualitzarPosicio, dibuixar. De moment la funcionalitat de comprovar pulsacions s'encarregar\u00e0 el m\u00e8tode de l'API de Processing keyPressed . Descarrega la soluci\u00f3 de l'activitat 11","title":"Programaci\u00f3 Modular"},{"location":"#tipus-compostos-de-dades","text":"Aprofitant que al tema de tipus compostos de dades hem vist algunes col\u00b7leccions o conjunts (arrays i matrius), veiem com podem afegir-li m\u00e9s funcionalitats al nostre projecte de la boleta. Com que ja podem moure la boleta per la pantalla de la nostra aplicaci\u00f3 amb els cursors, donem-li un objectiu al nostre personatge. Farem que la finalitat del joc siga que la nostra boleta persegueixi i es \"menge\" enemics . Suposem que aquests enemics s\u00f3n cercles d'un color diferent al de la boleta que apareixen de forma aleat\u00f2ria per la pantalla i es mantenen en la mateixa posici\u00f3 durant tot el joc, a m\u00e9s a m\u00e9s, en el moment que apareixen la boleta els ha de tocar per poder eliminar-los. Podriem fer, per exemple, que els enemics comencen a apareixer passat un temps i que vagen apareixent fins arribar a un m\u00e0xim de 10 enemics en total. El joc acaba quan la boleta s'haja \"menjat\" a tots els enemics. Analitzem amb m\u00e9s profunditat el plantejament anterior i vegem quins podrien ser els seus requeriments.","title":"Tipus Compostos de Dades"},{"location":"#programacio-orientada-a-objectes","text":"Canviem el paradigma de programaci\u00f3 del nostre joc de la boleta. Si fins ara el que hem fet ha sigut imaginar un conjunt de procediments que hem programat basant-nos en el paradigma de programaci\u00f3 estructurada, ara hem de fer el proc\u00e9s d'abstracci\u00f3 de la nostra aplicaci\u00f3 i veure-la com un conjunt d'objectes que tenen un comportament concret. Per\u00f2 comencem pel principi i seguim els passos que hem vist al Tema 6. 1. Quins elements de la nostra aplicaci\u00f3 han de ser desats o s'han de tenir en compte? La boleta, els enemics i un marcador (nou) que ens indicar\u00e0 tant el temps com les puntuacions (enemics mostrats i morts) 2. De cada element, quines dades ens interessen? Boleta: color, posici\u00f3, direcci\u00f3, velocitat, color, grand\u00e0ria. Enemic: posicio, color, grandaria. Marcador: posici\u00f3, dimensions, temps transcorregut, interval (temps entre que apareix un enemic i el seg\u00fcent), pr\u00f2xim interval (quan podr\u00e0 tornar a apareixer un enemic), marcadors (punts)... 3. A cada element, quines operacions associarem? Boleta: mostrar-se, actualitzar-se, moure's cap amunt, avall, dreta i esquerra, col\u00b7lisionar amb Enemics, rebotar, parar.. Enemic: mostrar-se, morir. Marcador: mostrar-se, actualitzar-se, controlar el temps i els marcadors dividits en dos: puntsA que ser\u00e0 el total d'enemics mostrats i puntsB que seran els que ja hem eliminat. El fet de que el marcador parle de puntsA i puntsB en lloc de enemics apareguts i morts \u00e9s perqu\u00e8 l'objecte marcador no ha de saber el significat dels valors que mostra (puntsA i puntsB) per tal de fer-lo m\u00e9s gen\u00e8ric i m\u00e9s reutilitzatble a altres aplicacions. De les respostes a les q\u00fcestions anteriors, el que hauriem de fer ara \u00e9s dissenyar un xicotet diagrama de classes que represente la realitat anterior. Per exemple: classDiagram direction LR Bola: int grandaria Bola: float velocitat Bola: color pinta Bola: PVector posicio Bola: PVector direccio Bola: Bola() Bola: Bola(Pvector pos, Pvector dir, float vel, int tam, color col) Bola: void mostra() Bola: void actualitza() Bola: void para() Bola: boolean colisionaAmb (Enemic e) Bola: boolean superaLimits (int alt, int ample) Bola: void giraDreta() Bola: void giraEsquerra() Bola: void giraDalt() Bola: void giraBaix() Enemic: PVector posicio Enemic: int grandaria Enemic: color pinta Enemic: Enemic() Enemic: void mostra() Enemic: PVector getPosicio() Enemic: int getGrandaria() Marcador: int ample Marcador: int alt Marcador: PVector posicio Marcador: int currentTime Marcador: int timeLapse Marcador: int nextLapse Marcador: int puntsA Marcador: int puntsB Marcador: String lblPuntsA Marcador: String lblPuntsB Marcador: bool passatInterval Marcador: Marcador() Marcador: Marcador(String strA, String strB, int lapse) Marcador: void mostra() Marcador: void actualitza() Marcador: void sumaPuntsA() Marcador: void sumaPuntsB() Marcador: int getPuntsA() Marcador: int getPuntsB() Marcador: String getTime() Marcador: boolean haPassatInterval() Main \"1\" --> \"1\" Bola Main \"1\" --> \"10\" Enemic Main \"1\" --> \"1\" Marcador Main: int maxEnemics=10 Main: void setup() Main: void draw() Main: inicilialitzaApp() Main: keyPressed() A partir d'aquest diagrama de classes ara ens quedaria implementar-les en Processing IDE per despr\u00e8s poder utilitzar-les des de l'aplicaci\u00f3 principal. Per tal de poder utilitzar les classes creades al pas anterior, podriem implementar una aplicaci\u00f3 main com la que mostra el seg\u00fcent diagrama de flux: graph LR subgraph \"GESTI\u00d3 MARCADOR\" style Ini fill:#0F0; Ini((Inici))-->A[Mostra Marcador]; A-->B{Queden enemics per matar?}; B-->|Si|C[Actualitza Marcador]; C-->D{Queden enemics per mostrar Y Ha passat un interval?}; D-->|Si|E[Crea Enemic Afegeix-lo Suma Apareguts]; end subgraph \"GESTI\u00d3 DE LA BOLETA\" D-->|No|F; E-->F[Mostra Bola Actualitza Bola]; F-->G{Supera Limits?}; G-->|Si|H[Rebota]; end subgraph \"GESTI\u00d3 DELS ENEMICS\" G-->|No|I; H-->I{Hi han enemics per mostrar?}; I-->|Si|J[Mostra Enemic]; I-->|No|B; J-->K{Col\u00b7lisiona amb la boleta}; K-->|Si|L[Elimina Enemic Suma Punts]; L-->I; K-->|No|I; end classDef primer fill:#EFF, clear:both, display:inline, clear: both class 1 primer class 2 primer class 3 primer class 4 primer Al final el resultat podria ser de la seg\u00fcent manera: Activitat 17. Conversi\u00f3 a POO Problema Soluci\u00f3 Converteix el joc de la boleta al paradigma de programaci\u00f3 orientada a objectes. Intenta seguir els passos que s'han explicat al tema 6 amb l'exemple del volc\u00e0 que s\u00f3n els mateixos que acabem d'explicar a l'apartat anterior. Descarrega la soluci\u00f3 de l'activitat 15","title":"Programaci\u00f3 orientada a objectes"},{"location":"#classe-animator-reutilitzacio-de-classes","text":"Fins ara els elements que hem usat per fer el nostre joc de la boleta s\u00f3n figures geom\u00e8triques est\u00e0tiques el que fa que en general siga un poc avorrit. En aquest seg\u00fcent apartat aprendrem com convertir els nostres objectes en figures animades. Aprofitant una de les caracter\u00edstiques principals del paradigma de Programaci\u00f3 Orientada a Objectes, la reutlitzaci\u00f3 del codi, incorporarem una nova classe al nostre joc: la classe Animation que podeu descarregar Ac\u00ed . Aquesta classe ens permet mitjan\u00e7ant l'\u00fas de sprite sheets crear animacions per al nostre personatge com la seg\u00fcent: Utlitzar aqueta classe \u00e9s relativament senzill: Incorporem la classe al nostre projecte copiant-la a la mateixa carpeta com una classe pr\u00f2pia m\u00e9s. Declarem un atribut Animation a qualsevol classe del nostre projecte que vulgam animar. Al constructor de la classe que volem animar instanciem l'objecte animation seguint les instruccions de la classe.","title":"Classe Animator - Reutilitzaci\u00f3 de classes"}]}